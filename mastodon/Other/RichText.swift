//
//  RichText.swift
//  mastodon
//
//  Created by Vyr Cossont on 2/2/19.
//  Copyright © 2019 Vyr Cossont. All rights reserved.
//

import Foundation
import HTMLEntities
import SwiftSoup

/// Support class for the String extension below.
final class RichText {
    fileprivate static let whitelistBasic = try! Whitelist.basic()
    fileprivate static let whitelistExtra = try! whitelistBasic
        .addTags("h1", "h2", "h3", "h4", "h5", "h6")
    
    fileprivate static let internalEncoding = String.Encoding.utf8
    
    /// See https://mathiasbynens.be/notes/css-escapes _at least_.
    fileprivate static func cssStringEscape(_ string: String) -> String {
        return "\"\(string.replacingOccurrences(of: "\"", with: "\\\""))\""
    }
    
    /// DEBUG(Vyr): should obviously do something else if this happens
    static let failure = NSAttributedString(string: "⚠️ RICH TEXT FAILURE")
}

extension Status {
    func asRichText(suffix: String? = nil) -> NSAttributedString? {
        return self.content.cleanRichDefaults(
            emojis: self.emojis,
            htmlSuffix: suffix.map { x in "<p>\(x.htmlEscape())</p>" }
        )
    }
}

extension Account {
    func displayNameAsRichText(suffix: String? = nil) -> NSAttributedString? {
        // TODO(Vyr): display name whitelist should have basically nothing in it
        // TODO(Vyr): username font should be UIFont.boldSystemFont(ofSize: Colours.fontSize1)
        return self.displayName.cleanRichDefaults(
            emojis: self.emojis,
            htmlSuffix: suffix.map { $0.htmlEscape() }
        )
    }

    func noteAsRichText() -> NSAttributedString? {
        return self.note.cleanRichDefaults(emojis: self.emojis)
    }
}

/// Add methods to turn an HTML string into an attributed string.
extension String {
    func cleanRichDefaults(
        emojis: [Emoji] = [],
        htmlSuffix: String? = nil
        ) -> NSAttributedString?
    {
        return cleanRich(
            whitelist: RichText.whitelistExtra,
            bodyFont: UIFont.systemFont(ofSize: Colours.fontSize1),
            textColor: Colours.black,
            linkColor: Colours.tabSelected,
            emojis: emojis,
            htmlSuffix: htmlSuffix
        )
    }

    /// Translate some acceptable subset of HTML into an attributed string.
    /// Allow HTML tags corresponding (approximately) to what Markdown allows.
    /// See https://cocoapods.org/pods/SwiftSoup#sanitize-untrusted-html-to-prevent-xss
    func cleanRich(
        whitelist: Whitelist,
        bodyFont: UIFont,
        textColor: UIColor,
        linkColor: UIColor,
        emojis: [Emoji],
        htmlSuffix: String?
        ) -> NSAttributedString?
    {
        // Initialize with fallback white.
        var textRed: CGFloat = 1.0
        var textGreen: CGFloat = 1.0
        var textBlue: CGFloat = 1.0
        var textAlpha: CGFloat = 1.0
        textColor.getRed(&textRed, green: &textGreen, blue: &textBlue, alpha: &textAlpha)

        // Initialize with fallback blue.
        var linkRed: CGFloat = 0.0
        var linkGreen: CGFloat = 0.0
        var linkBlue: CGFloat = 1.0
        var linkAlpha: CGFloat = 1.0
        linkColor.getRed(&linkRed, green: &linkGreen, blue: &linkBlue, alpha: &linkAlpha)

        // Yes, CSS RGB values are either 0-255 or 0%-100% while alpha values are floats.
        // Try not to think about it too hard.
        let styleStart = """
            <html><head><style>
            body {
            font-size: \(bodyFont.pointSize)pt;
            font-family: \(RichText.cssStringEscape(bodyFont.familyName));
            color: rgba(\(Int(textRed * 100))%, \(Int(textGreen * 100))%, \(Int(textBlue * 100))%, \(textAlpha));
            }
            a {
            color: rgba(\(Int(linkRed * 100))%, \(Int(linkGreen * 100))%, \(Int(linkBlue * 100))%, \(linkAlpha));
            }
            blockquote {
            text-indent: 2em;
            }
            </style></head><body>
            """
        let styleEnd = """
            \(htmlSuffix ?? "")
            </body></html>
            """

        let html: String
        do {
            guard let success = try SwiftSoup.clean(self, whitelist) else {
                print("RichText: HTML cleaning failed: no exception!")
                return nil
            }
            html = styleStart + success + styleEnd
        } catch {
            print("RichText: HTML cleaning failed: \(String(describing: error))!")
            return nil
        }

        guard let data = html.data(using: RichText.internalEncoding) else {
            print("RichText: HTML encoding to data failed: no exception!")
            return nil
        }

        // Apple recommends this HTML importer only for simple HTML generated by Markdown, etc.
        // https://developer.apple.com/documentation/foundation/nsattributedstring/1524613-init#discussion
        // TODO(Vyr): see if perf impact is real: http://www.robpeck.com/2015/04/nshtmltextdocumenttype-is-slow/
        let mutableAttributedString: NSMutableAttributedString
        let options: [NSAttributedString.DocumentReadingOptionKey: Any] = [
            NSAttributedString.DocumentReadingOptionKey.documentType: NSAttributedString.DocumentType.html,
            NSAttributedString.DocumentReadingOptionKey.characterEncoding: NSNumber(value: RichText.internalEncoding.rawValue),
            ]
        do {
            let success = try NSMutableAttributedString(data: data, options: options, documentAttributes: nil)
            mutableAttributedString = success
        } catch {
            print("RichText: HTML data parsing failed: \(String(describing: error))!")
            return nil
        }
        
        for emoji in emojis {
            let textAttachment = NSTextAttachment()
            textAttachment.loadImageUsingCache(withUrl: emoji.url.absoluteString)
            textAttachment.bounds = CGRect(x: 0, y: Int(-4), width: Int(bodyFont.lineHeight), height: Int(bodyFont.lineHeight))
            let attrStringWithImage = NSAttributedString(attachment: textAttachment)
            while mutableAttributedString.mutableString.contains(":\(emoji.shortcode):") {
                let range: NSRange = (mutableAttributedString.mutableString as NSString).range(of: ":\(emoji.shortcode):")
                mutableAttributedString.replaceCharacters(in: range, with: attrStringWithImage)
            }
        }

        return mutableAttributedString
    }
}
